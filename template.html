<html>
	<head>
		<meta charset="utf-8">
		<title>Overlay</title>
		<style>
			body {
				margin: 0;
			}
			svg {
				max-width: 100vw;
				max-height: 100vh;
				margin: auto;
				box-shadow: 0 0 0 max(100vw, 100vh) red
			}
		</style>
	</head>
	<body>
		OVERLAY_SVG_GOES_HERE
		<script>
			// Find all the placeholders on the page
			let texts = document.querySelectorAll('text');

			/** A list of <text> elements whose text can be modified. */
			let placeholders = [];

			/** A set storing text alignment options for each placeholder. */
			let placeholderOptions = new Map();

			/**
			 * Updates the text of the given text element, respecting its
			 * configured text alignment.
			 */
			function updateText(el, newText) {
				if (!placeholderOptions.has(el)) {
					throw new Error('element is not a placeholder');
				}
				let {
					horizontalAlign,
				} = placeholderOptions.get(el);

				let oldRect = el.getBBox();

				el.textContent = newText;
				let newRect = el.getBBox();

				let horizontalOffset;
				if (horizontalAlign == 'center') {
					horizontalOffset = (oldRect.width - newRect.width) / 2;
				} else if (horizontalAlign == 'right') {
					horizontalOffset = oldRect.width - newRect.width;
				} else { // left or unknown
					horizontalOffset = 0;
				}

				let currentTransform = el.getAttribute('transform');
				let newTransform = currentTransform.replace(/matrix\(1 0 0 1 ([\d\.]+) ([\d\.]+)\)/, (_, x, y) => `matrix(1 0 0 1 ${parseFloat(x) + horizontalOffset} ${parseFloat(y)})`);
				el.setAttribute('transform', newTransform)
			}

			/**
			 * A map of state fields to placeholder <text> elements whose text
			 * content should reflect the value of that field.
			 */
			const valuePlaceholderMap = {}

			/** Updates the displayed value of a state field. */
			function set(field, value) {
				for (const el of valuePlaceholderMap[field]) {
					updateText(el, value);
				}
			}

			/** Takes a number of seconds and formats it into a nice string. */
			function formatGameTime (seconds, isOT) {
				let minutesText = Math.floor(seconds / 60);
				let secondsText = `${seconds % 60}`;
				if (secondsText.length < 2) {
					secondsText = `0${secondsText}`;
				}
				return `${isOT ? '+' : ''}${minutesText}:${secondsText}`;
			}

			// Wait for document to load - we need fonts and stuff to be ready
			// before we can do bounding box calculations on the text elements
			document.addEventListener('readystatechange', () => {
				if (document.readyState !== 'complete') {
					return;
				}

				// Set up all the text placeholders
				for (const text of texts) {
					if (!text.textContent.match(/^[#\s]+$/)) {
						continue;
					}

					placeholders.push(text);
					placeholderOptions.set(text, {
						horizontalAlign: 'center',
					});

					updateText(text, '');
				}

				// Set up connections between game state and placeholders
				valuePlaceholderMap.score0 = [placeholders[2]];
				valuePlaceholderMap.score1 = [placeholders[1]];
				valuePlaceholderMap.clock = [placeholders[0]];

				// Connect to SOS plugin to receive game state updates
				let sosConnection = new WebSocket(`ws://localhost:49122`);
				sosConnection.addEventListener('close', event => {
					console.error('SOS connection closed:', event.code);
				});
				sosConnection.addEventListener('message', e => {
					const {event, data} = JSON.parse(e.data);
					if (event === 'sos:version') {
						console.log('SOS version:', data);
						return;
					}

					// Listen for game state updates and display values
					if (event === 'game:update_state') {
						console.log('received game state')
						set('score0', data.game.teams[0].score);
						set('score1', data.game.teams[1].score);
						set('clock', formatGameTime(data.game.time_seconds, data.game.isOT));
					}
				});
			});
		</script>
	</body>
</html>
